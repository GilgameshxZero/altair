#include <cmath>

//A library of useful functions for general computational geometry calculations. For more specific functions, such as Convex Hull, see other files.

struct Point
{
	double x, y;
};

//Finds the distance between two points.
//Point p1 (in): The first point.
//Point p2 (in): The second point.
double PointPointDistance (Point p1, Point p2)
{
	return sqrt ((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));
}

//Finds distance between two points
double PointPointDistance (double p1[2], double p2[2])
{
	return sqrt ((p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[2]) * (p1[1] - p2[2]));
}

//Finds intersection of two lines and if they intersect or not.
bool LineIntersection (double intersection[2], double p1[2], double p2[2], double p3[2], double p4[2])
{
	double a = (p4[0] - p3[0]) * (p1[1] - p3[1]) - (p4[1] - p3[1]) * (p1[0] - p3[0]), 
		b = (p4[1] - p3[1]) * (p2[0] - p1[0]) - (p4[0] - p3[0]) * (p2[1] - p1[1]);

	if (b == 0)
		return false;

	intersection[0] = p1[0] + (p2[0] - p1[0]) * a / b;
	intersection[1] = p1[1] + (p2[1] - p1[1]) * a / b;

	return true;
}

bool LineIntersection (Point *intersection, Point p1, Point p2, Point p3, Point p4)
{
	double a = (p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x), 
		b = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);

	if (b == 0) //Parallel.
		return true;

	intersection->x = p1.x + (p2.x - p1.x) * a / b;
	intersection->y = p1.y + (p2.y - p1.y) * a / b;

	return false;
}

//Determines if a point is on a segment, not counting the endpoints.
bool PointOnSegmentExclusive (double point[2], double p1[2], double p2[2])
{
	//If vertical line (p1, p2)
	if (p1[0] == p2[0])
	{
		//If x coordinate is the same and the y coordinate is between inclusive, then it is on the segment.
		if (point[0] == p1[0] && ((point[1] > p1[1] && point[1] < p2[1]) || (point[1] < p1[1] && point[1] > p2[1])))
			return true;
		else
			return false;
	}
	//If a horozontal line.
	else if (p1[1] == p2[1])
	{
		//If y coordinate is the same and the x coordinate is between inclusive, then it is on the segment.
		if (point[1] == p1[1] && ((point[0] > p1[0] && point[0] < p2[0]) || (point[0] < p1[0] && point[0] > p2[0])))
			return true;
		else
			return false;
	}
	//If a subsegment is vertical (messes up slope calculations later), then return false.
	else if ((point[0] == p1[0]) || (point[0] == p2[0]))
		return false;
	//If not horozontal nor vertical line (p1, p2)
	else
	{
		double x = static_cast<double>((point[1] - p1[1]) / (point[0] - p1[0]));
		double y = static_cast<double>((point[1] - p2[1]) / (point[0] - p2[0]));

		//Test if the slopes are equal for the subsegments (p1, point) and (point, p2) to the third decimal.
		if (static_cast<int>(x * 1000) == static_cast<int>(y * 1000))
		{
			//If the x and y coordinates of the point are between p1 and p2
			if (((point[1] > p1[1] && point[1] < p2[1]) || (point[1] < p1[1] && point[1] > p2[1])) && ((point[0] > p1[0] && point[0] < p2[0]) || (point[0] < p1[0] && point[0] > p2[0])))
				return true;
			else
				return false;
		}
		else
			return false;
	}
}

//Determines if a point is on a segment, including the endpoints.
bool PointOnSegmentInclusive (double point[2], double p1[2], double p2[2])
{
	//If vertical line (p1, p2)
	if (p1[0] == p2[0])
	{
		//If x coordinate is the same and the y coordinate is between inclusive, then it is on the segment.
		if (point[0] == p1[0] && ((point[1] >= p1[1] && point[1] <= p2[1]) || (point[1] <= p1[1] && point[1] >= p2[1])))
			return true;
		else
			return false;
	}
	//If a horozontal line.
	else if (p1[1] == p2[1])
	{
		//If y coordinate is the same and the x coordinate is between inclusive, then it is on the segment.
		if (point[1] == p1[1] && ((point[0] >= p1[0] && point[0] <= p2[0]) || (point[0] <= p1[0] && point[0] >= p2[0])))
			return true;
		else
			return false;
	}
	//If an endpoint and point are the same point
	else if (((point[0] == p1[0]) && (point[1] == p1[1])) || ((point[0] == p2[0]) && (point[1] == p2[1])))
		return true;
	//If a subsegment is vertical (messes up slope calculations later), then return false.
	else if ((point[0] == p1[0]) || (point[0] == p2[0]))
		return false;
	//If not horozontal nor vertical line (p1, p2)
	else
	{
		float x = static_cast<float>((point[1] - p1[1]) / (point[0] - p1[0]));
		float y = static_cast<float>((point[1] - p2[1]) / (point[0] - p2[0]));

		//Test if the slopes are equal for the subsegments (p1, point) and (point, p2) to the third decimal.
		if (static_cast<int>(x * 1000) == static_cast<int>(y * 1000))
		{
			//If the x and y coordinates of the point are between p1 and p2
			if (((point[1] >= p1[1] && point[1] <= p2[1]) || (point[1] <= p1[1] && point[1] >= p2[1])) && ((point[0] >= p1[0] && point[0] <= p2[0]) || (point[0] <= p1[0] && point[0] >= p2[0])))
				return true;
			else
				return false;
		}
		else
			return false;
	}
}

bool PointOnSegmentInclusive (Point point, Point l1, Point l2)
{
	//If vertical line (l1, l2)
	if (l1.x == l2.x)
	{
		//If x coordinate is the same and the y coordinate is between inclusive, then it is on the segment.
		if (point.x == l1.x && ((point.y >= l1.y && point.y <= l2.y) || (point.y <= l1.y && point.y >= l2.y)))
			return true;
		else
			return false;
	}
	//If a horozontal line.
	else if (l1.y == l2.y)
	{
		//If y coordinate is the same and the x coordinate is between inclusive, then it is on the segment.
		if (point.y == l1.y && ((point.x >= l1.x && point.x <= l2.x) || (point.x <= l1.x && point.x >= l2.x)))
			return true;
		else
			return false;
	}
	//If an endpoint and point are the same point
	else if (((point.x == l1.x) && (point.y == l1.y)) || ((point.x == l2.x) && (point.y == l2.y)))
		return true;
	//If a subsegment is vertical (messes up slope calculations later), then return false.
	else if ((point.x == l1.x) || (point.x == l2.x))
		return false;
	//If not horozontal nor vertical line (l1, l2)
	else
	{
		float x = static_cast<float>((point.y - l1.y) / (point.x - l1.x));
		float y = static_cast<float>((point.y - l2.y) / (point.x - l2.x));

		//Test if the slopes are equal for the subsegments (l1, point) and (point, l2) to the third decimal.
		if (static_cast<int>(x * 1000) == static_cast<int>(y * 1000))
		{
			//If the x and y coordinates of the point are between l1 and l2
			if (((point.y >= l1.y && point.y <= l2.y) || (point.y <= l1.y && point.y >= l2.y)) && ((point.x >= l1.x && point.x <= l2.x) || (point.x <= l1.x && point.x >= l2.x)))
				return true;
			else
				return false;
		}
		else
			return false;
	}
}

//Determines if two segments are intersecting each other not including endpoints.
bool SegmentIntersectionExclusive (double intersection[2], double p1[2], double p2[2], double p3[2], double p4[2])
{
	if (LineIntersection (intersection, p1, p2, p3, p4) == false) //If segments are parallel.
		return false;

	if (PointOnSegmentExclusive (intersection, p1, p2) && PointOnSegmentExclusive (intersection, p3, p4)) //Because lines are linear, we test if the intersection x-coordinate of intersection is between both of the lines' x-coordinates.
		return true;

	return false;
}

//Determines if two segments are intersecting including endpoints.
bool SegmentIntersectionInclusive (double intersection[2], double p1[2], double p2[2], double p3[2], double p4[2])
{
	if (LineIntersection (intersection, p1, p2, p3, p4) == false) //If segments are parallel.
		return false;

	if (PointOnSegmentInclusive (intersection, p1, p2) && PointOnSegmentInclusive (intersection, p3, p4)) //Because lines are linear, we test if the intersection x-coordinate of intersection is between both of the lines' x-coordinates.
		return true;

	return false;
}

//Determines if two points are on the same side of a line.
bool PointsOnSameSideOfLine (double p1[2], double p2[2], double l1[2], double l2[2])
{
	float intersection[2], a, b;

	if (LineIntersection (intersection, p1, p2, l1, l2) == false) //If these lines are parallel:
		return true; //Then they are on the same side of line l.

	a = PointPointDistance (p1, intersection);
	b = PointPointDistance (p2, intersection);

	if (a > b)
	{
		if (PointPointDistance (p1, p2) < a)
			return true;

		return false;
	}
	else
	{
		if (PointPointDistance (p1, p2) < b)
			return true;

		return false;
	}
}

bool PointsOnSameSideOfLineInclusive (bool *out, Point p1, Point p2, Point l1, Point l2)
{
	Point intersection;
	double a, b;

	if (LineIntersection (&intersection, p1, p2, l1, l2) == true) //If these lines are parallel:
	{
		*out = true; //Then they are on the same side of line l.
		return false;
	}

	a = PointPointDistance (p1, intersection);
	b = PointPointDistance (p2, intersection);

	if (a > b)
	{
		if (PointPointDistance (p1, p2) <= a)
			*out = true;
		else
			*out = false;
	}
	else
	{
		if (PointPointDistance (p1, p2) <= b)
			*out = true;
		else
			*out = false;
	}

	return false;
}

//This function determines if a points is inside a polygon, counting it if it lies on an edge.
//bool *inside (out): It will contain true if point is inside polygon, false if not.
//Point point (in): Pass a point to test whether it is inside polygon or not.
//Point *poly (in): Pass a polygon to test whether the point is inside this polygon or not. These points must be arranged in order.
//size_t cpoly (in): Pass the number of points in the poly array.

//Only works for convex polygons.
bool PointInsidePolygonInclusive (bool *inside, Point point, Point *poly, size_t cpoly)
{
	Point mpoint;
	bool out;

	if (cpoly == 2) //Not a polygon, but a line.
	{
		*inside = PointOnSegmentInclusive (point, poly[0], poly[1]);

		return false;
	}

	//Take the average of the vertices in the polygon. Test whether point is on the same side of every edge of polygon as that average is. The first vertice is guaranteed to be inside the polygon, since this is inclusive.
	mpoint.x = mpoint.y = 0;

	for (int a = 0;a < cpoly;a++)
	{
		mpoint.x += poly[a].x;
		mpoint.y += poly[a].y;
	}

	mpoint.x /= cpoly;
	mpoint.y /= cpoly;

	for (int a = 1;a < cpoly;a++)
	{
		PointsOnSameSideOfLineInclusive (&out, mpoint, point, poly[a - 1], poly[a]);

		if (out == false)
		{
			*inside = false;
			return false;
		}
	}
	
	PointsOnSameSideOfLineInclusive (&out, mpoint, point, poly[0], poly[cpoly - 1]);

	if (out == false)
	{
		*inside = false;
		return false;
	}

	*inside = true;
	return false;
}